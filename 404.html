<script>
        window.drawPolarCurve = (c0, c90) => {
            const canvas = document.getElementById('iesCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const radius = Math.min(w, h) / 2 - 40; // 留点边距写文字
            const cx = w / 2;
            const cy = h / 2;

            ctx.clearRect(0, 0, w, h);

            // --- 1. 绘制极坐标网格 ---
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // 同心圆 (20%, 40% ... 100%)
            for(let i=1; i<=5; i++) {
                ctx.beginPath();
                ctx.arc(cx, cy, radius * (i/5), 0, 2 * Math.PI);
                ctx.stroke();
            }

            // 放射线 (每30度)
            for(let i=0; i<12; i++) {
                const ang = (i * 30) * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + radius * Math.cos(ang), cy + radius * Math.sin(ang));
                ctx.stroke();
            }

            // --- 2. 定义画线函数 ---
            const drawCurve = (data, color) => {
                if(!data || data.length === 0) return;
                const maxVal = Math.max(...Math.max(...c0), ...Math.max(...c90)); // 全局最大值归一化

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // IES 垂直角通常是从 0 (下) 到 180 (上) 或者 0 (下) 到 90 (水平)
                // 这里我们做一个简单的映射：0度在下方(270度方向)，90度在右侧(0度方向)
                // 注意：Canvas 0度是3点钟方向，顺时针
                
                for(let i=0; i<data.length; i++) {
                    // 假设数据是均匀分布的 0 -> 180 度
                    const vAngleDeg = i * (180 / (data.length - 1)); 
                    
                    // 转换为极坐标角度 (0度对应 Canvas的 90度位置即下方)
                    // 这是一个简化的映射，真实 IES 比较复杂，但这足够显示形状
                    const theta = (vAngleDeg + 90) * Math.PI / 180;

                    const r = (data[i] / maxVal) * radius;
                    const x = cx + r * Math.cos(theta);
                    const y = cy + r * Math.sin(theta);

                    if(i===0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                // 镜像画另一半 (假设对称，为了好看)
                for(let i=data.length-1; i>=0; i--) {
                    const vAngleDeg = i * (180 / (data.length - 1)); 
                    const theta = (90 - vAngleDeg) * Math.PI / 180; // 镜像
                    const r = (data[i] / maxVal) * radius;
                    const x = cx + r * Math.cos(theta);
                    const y = cy + r * Math.sin(theta);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            };

            // --- 3. 绘制数据 ---
            if(c0) drawCurve(c0, 'red');     // C0-180 (红色)
            if(c90) drawCurve(c90, 'blue');  // C90-270 (蓝色)
        };
    </script>
